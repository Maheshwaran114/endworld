/*
   Generated by EX4-TO-MQ4 decompiler V4.0.224.1 []
   Website: http://purebeam.biz
   E-mail : purebeam@gmail.com
*/

#property indicator_separate_window
#property indicator_minimum -1.1
#property indicator_maximum 1.1
#property indicator_buffers 6
#property indicator_color1 Yellow
#property indicator_color2 Red
#property indicator_color3 DeepSkyBlue
#property indicator_color4 Red
#property indicator_color5 White
#property indicator_color6 White

extern int FS30Range = 5;
extern int FilterPeriod = 17;
extern double MartFiltr = 2.0;
extern int PriceConst = 6;
extern int MaPeriod = 5;
extern int MaMode = 3;
extern double LevelsCross = 0.95;
extern int Countbars = 300;
extern bool AlertOn = TRUE;
extern int ArrowUp = 108;
extern int ArrowDown = 108;
int gi_unused_128 = 20;
double g_ibuf_132[];
double g_ibuf_136[];
double g_ibuf_140[];
double g_ibuf_144[];
double g_ibuf_148[];
double g_ibuf_152[];
double g_ibuf_156[];
double g_ibuf_160[];
int gi_164 = 14;
double gda_168[];
double gd_172;
int gia_180[];
int gia_184[];
bool gi_188 = FALSE;
bool gi_192 = FALSE;

int init() {
   IndicatorDigits(MarketInfo(Symbol(), MODE_DIGITS));
   IndicatorBuffers(8);
   SetIndexBuffer(0, g_ibuf_132);
   SetIndexStyle(0, DRAW_LINE);
   SetIndexBuffer(1, g_ibuf_144);
   SetIndexStyle(1, DRAW_LINE);
   SetIndexBuffer(2, g_ibuf_148);
   SetIndexStyle(2, DRAW_ARROW);
   SetIndexBuffer(3, g_ibuf_152);
   SetIndexStyle(3, DRAW_ARROW);
   SetIndexArrow(2, ArrowUp);
   SetIndexArrow(3, ArrowDown);
   SetIndexBuffer(4, g_ibuf_156);
   SetIndexStyle(4, DRAW_ARROW);
   SetIndexBuffer(5, g_ibuf_160);
   SetIndexStyle(5, DRAW_ARROW);
   SetIndexBuffer(6, g_ibuf_136);
   SetIndexStyle(6, DRAW_NONE);
   SetIndexBuffer(7, g_ibuf_140);
   SetIndexStyle(7, DRAW_NONE);
   SetLevelValue(0, LevelsCross);
   SetLevelValue(1, -LevelsCross);
   SetLevelValue(2, 0);
   ArrayResize(gda_168, gi_164);
   ArrayResize(gia_180, gi_164);
   ArrayResize(gia_184, gi_164);
   IndicatorShortName(WindowExpertName() + "( SR:" + FS30Range + ", FP:" + FilterPeriod + ", MA:" + MaPeriod + " )");
   gd_172 = MathPow(10, Digits);
   return (0);
}

int deinit() {
   return (0);
}

int start() {
   int li_0;
   int li_12;
   int li_16;
   if (gi_164 > 30) return (-1);
   int li_20 = IndicatorCounted();
   if (li_20 > 0) li_20--;
   int li_8 = Countbars - li_20 - 1;
   if (li_0 > li_12) li_12 = li_0;
   if (li_12 < Countbars - 1) li_8 = Countbars - 1;
   for (li_0 = 0; li_0 < li_8; li_0++) {
      g_ibuf_148[li_0] = EMPTY_VALUE;
      g_ibuf_152[li_0] = EMPTY_VALUE;
      g_ibuf_156[li_0] = EMPTY_VALUE;
      g_ibuf_160[li_0] = EMPTY_VALUE;
      g_ibuf_132[li_0] = EMPTY_VALUE;
      g_ibuf_144[li_0] = EMPTY_VALUE;
   }
   for (li_0 = li_8; li_0 >= 0; li_0--) MartAxis(li_0);
   for (li_0 = li_8; li_0 >= 0; li_0--) SmoothOverMart(li_0);
   for (li_0 = li_8; li_0 >= 0; li_0--) {
      for (int l_index_4 = 0; l_index_4 < gi_164; l_index_4++) gia_180[l_index_4] = MathRound((g_ibuf_140[li_0 + l_index_4]) * gd_172);
      RankPrices(gia_180);
      g_ibuf_132[li_0] = FS30ver30(gda_168, gi_164);
      if (g_ibuf_132[li_0] > 1.0) g_ibuf_132[li_0] = 1.0;
      if (g_ibuf_132[li_0] < -1.0) g_ibuf_132[li_0] = -1.0;
   }
   for (li_0 = li_8; li_0 >= 0; li_0--) g_ibuf_144[li_0] = iMAOnArray(g_ibuf_132, 0, MaPeriod, 0, MaMode, li_0);
   for (li_0 = li_8; li_0 >= 0; li_0--) {
      if (g_ibuf_132[li_0] > g_ibuf_144[li_0] && g_ibuf_132[li_0] > (-LevelsCross) && g_ibuf_132[li_0] < 0.0 && g_ibuf_144[li_0] < 0.0 && li_0 != 0 && li_16 != 1) {
         li_16 = 1;
         g_ibuf_148[li_0] = g_ibuf_132[li_0];
         g_ibuf_152[li_0] = EMPTY_VALUE;
         if (AlertOn && li_0 == 1 && !gi_188) {
            Alert(WindowExpertName() + " is crossing UP on" + " " + Symbol(), " ", Period() + " " + "minute charts");
            gi_188 = TRUE;
            gi_192 = FALSE;
         }
      } else {
         if (g_ibuf_132[li_0] < g_ibuf_144[li_0] && g_ibuf_132[li_0] < LevelsCross && g_ibuf_132[li_0] > 0.0 && g_ibuf_144[li_0] > 0.0 && li_0 != 0 && li_16 != -1) {
            li_16 = -1;
            g_ibuf_152[li_0] = g_ibuf_132[li_0];
            g_ibuf_148[li_0] = EMPTY_VALUE;
            if (AlertOn && li_0 == 1 && !gi_192) {
               Alert(WindowExpertName() + " is crossing DOWN on" + " " + Symbol(), " ", Period() + " " + "minute charts");
               gi_188 = FALSE;
               gi_192 = TRUE;
            }
         }
      }
   }
   for (li_0 = li_8; li_0 >= 0; li_0--) {
      if (g_ibuf_132[li_0] > g_ibuf_144[li_0] && g_ibuf_144[li_0] > (-LevelsCross) && g_ibuf_132[li_0] < 0.0 && g_ibuf_144[li_0] < 0.0 && li_0 != 0 && li_16 != 1) {
         li_16 = 1;
         g_ibuf_156[li_0] = g_ibuf_132[li_0];
         g_ibuf_160[li_0] = EMPTY_VALUE;
      } else {
         if (g_ibuf_132[li_0] < g_ibuf_144[li_0] && g_ibuf_144[li_0] < LevelsCross && g_ibuf_132[li_0] > 0.0 && g_ibuf_144[li_0] > 0.0 && li_0 != 0 && li_16 != -1) {
            li_16 = -1;
            g_ibuf_160[li_0] = g_ibuf_132[li_0];
            g_ibuf_156[li_0] = EMPTY_VALUE;
         }
      }
   }
   if (li_0 > li_12) li_12 = li_0;
   return (0);
}

void MartAxis(int ai_0) {
   int li_4;
   int l_count_8;
   int li_12;
   int li_16;
   double ld_24;
   switch (PriceConst) {
   case 0:
      g_ibuf_136[ai_0] = iMA(NULL, 0, FS30Range + 1, 0, MODE_LWMA, PRICE_CLOSE, ai_0);
      break;
   case 1:
      g_ibuf_136[ai_0] = iMA(NULL, 0, FS30Range + 1, 0, MODE_LWMA, PRICE_OPEN, ai_0);
      break;
   case 2:
      g_ibuf_136[ai_0] = iMA(NULL, 0, FS30Range + 1, 0, MODE_LWMA, PRICE_HIGH, ai_0);
      break;
   case 3:
      g_ibuf_136[ai_0] = iMA(NULL, 0, FS30Range + 1, 0, MODE_LWMA, PRICE_LOW, ai_0);
      break;
   case 4:
      g_ibuf_136[ai_0] = iMA(NULL, 0, FS30Range + 1, 0, MODE_LWMA, PRICE_MEDIAN, ai_0);
      break;
   case 5:
      g_ibuf_136[ai_0] = iMA(NULL, 0, FS30Range + 1, 0, MODE_LWMA, PRICE_TYPICAL, ai_0);
      break;
   case 6:
      g_ibuf_136[ai_0] = iMA(NULL, 0, FS30Range + 1, 0, MODE_LWMA, PRICE_WEIGHTED, ai_0);
      break;
   default:
      g_ibuf_136[ai_0] = iMA(NULL, 0, FS30Range + 1, 0, MODE_LWMA, PRICE_WEIGHTED, ai_0);
   }
   for (int li_20 = ai_0 + FS30Range + 2; li_20 > ai_0; li_20--) {
      ld_24 = 0.0;
      li_4 = 0;
      l_count_8 = 0;
      li_12 = li_20 + FS30Range;
      li_16 = li_20 - FS30Range;
      if (li_16 < ai_0) li_16 = ai_0;
      while (li_12 >= li_20) {
         l_count_8++;
         ld_24 += l_count_8 * FS30Price(li_12);
         li_4 += l_count_8;
         li_12--;
      }
      while (li_12 >= li_16) {
         l_count_8--;
         ld_24 += l_count_8 * FS30Price(li_12);
         li_4 += l_count_8;
         li_12--;
      }
      g_ibuf_136[li_20] = ld_24 / li_4;
   }
}

double FS30Price(int ai_0) {
   switch (PriceConst) {
   case 0:
      return (Close[ai_0]);
   case 1:
      return (Open[ai_0]);
   case 2:
      return (High[ai_0]);
   case 3:
      return (Low[ai_0]);
   case 4:
      return ((High[ai_0] + Low[ai_0]) / 2.0);
   case 5:
      return ((Close[ai_0] + High[ai_0] + Low[ai_0]) / 3.0);
   case 6:
      return ((2.0 * Close[ai_0] + High[ai_0] + Low[ai_0]) / 4.0);
   }
   return (Close[ai_0]);
}

void SmoothOverMart(int ai_0) {
   double ld_4 = g_ibuf_136[ArrayMaximum(g_ibuf_136, FilterPeriod, ai_0)];
   double ld_12 = g_ibuf_136[ArrayMinimum(g_ibuf_136, FilterPeriod, ai_0)];
   g_ibuf_140[ai_0] = (2.0 * (MartFiltr + 2.0) * g_ibuf_136[ai_0] - (ld_4 + ld_12)) / 2.0 / (MartFiltr + 1.0);
}

double FS30ver30(double ada_0[], int ai_4) {
   double ld_16;
   for (int l_index_24 = 0; l_index_24 < ai_4; l_index_24++) ld_16 += MathPow(ada_0[l_index_24] - l_index_24 - 1.0, 2);
   double ld_ret_8 = 1 - 6.0 * ld_16 / (MathPow(ai_4, 3) - ai_4);
   return (ld_ret_8);
}

void RankPrices(int aia_0[]) {
   double ld_4;
   double ld_12;
   int l_index_24;
   int li_32;
   int li_36;
   int li_40;
   double lda_44[];
   ArrayResize(lda_44, gi_164);
   ArrayCopy(gia_184, aia_0);
   for (int l_index_20 = 0; l_index_20 < gi_164; l_index_20++) lda_44[l_index_20] = l_index_20 + 1;
   ArraySort(gia_184, WHOLE_ARRAY, 0, MODE_DESCEND);
   for (l_index_20 = 0; l_index_20 < gi_164 - 1; l_index_20++) {
      if (gia_184[l_index_20] == gia_184[l_index_20 + 1]) {
         li_32 = gia_184[l_index_20];
         l_index_24 = l_index_20 + 1;
         li_36 = 1;
         ld_12 = l_index_20 + 1;
         while (l_index_24 < gi_164) {
            if (gia_184[l_index_24] != li_32) break;
            li_36++;
            ld_12 += l_index_24 + 1;
            l_index_24++;
         }
         ld_4 = li_36;
         ld_12 /= ld_4;
         for (int li_28 = l_index_20; li_28 < l_index_24; li_28++) lda_44[li_28] = ld_12;
         l_index_20 = l_index_24;
      }
   }
   for (l_index_20 = 0; l_index_20 < gi_164; l_index_20++) {
      li_40 = aia_0[l_index_20];
      for (l_index_24 = 0; l_index_24 < gi_164; l_index_24++) {
         if (li_40 == gia_184[l_index_24]) {
            gda_168[l_index_20] = lda_44[l_index_24];
            break;
         }
      }
   }
}